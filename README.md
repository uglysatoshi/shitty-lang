> "Если древние дела не помогают, не следует им следовать; если старые слова не верны, не следует им верить." - Конфуций

# Задание 

Разработка экспертной системы, предназначений для консультации в отношении покупки стиральной машины.
# Теория

## Что такое логическое программирование?

Логическое программирование - парадигма (модель) программирования основанная на логике: компьютеру даются факты и правила, на основе которых он автоматически доказывает или опровергает теоремы. Одним из самых популярных языков логического программирования является Prolog. Именно на его примере я буду объяснять эту парадигму программирования. Начнем.
## Виды Prolog и их отличия

Prolog (Programming in Logic) — это декларативный язык программирования, используемый для символьного вычисления и искусственного интеллекта. Существует несколько различных реализаций Prolog, и вот некоторые из наиболее известных видов:

1. **SWI-Prolog**: Это одна из наиболее популярных и широко используемых реализаций Prolog. SWI-Prolog предлагает мощные инструменты для разработки, включая встроенные библиотеки, поддержку интерфейсов с другими языками программирования и расширенные возможности отладки.

2. **GNU Prolog (gprolog)**: Еще одна известная реализация Prolog. Она имеет открытый исходный код и поддерживает большинство функций стандарта Prolog.

3. **YAP (Yet Another Prolog)**: Это компактная и быстрая реализация Prolog, которая активно поддерживается и распространяется в виде открытого исходного кода.

4. **SICStus Prolog**: Это коммерческая реализация Prolog с множеством дополнительных инструментов и возможностей для разработки приложений на Prolog.

Отличия между различными реализациями Prolog могут включать в себя:

- **Производительность**: Некоторые реализации могут быть более эффективными или быстрыми благодаря оптимизациям или специфическим особенностям их реализации.

- **Дополнительные библиотеки и инструменты**: Разные реализации могут предоставлять различные наборы библиотек и инструментов для упрощения разработки и расширения функциональности.

- **Совместимость со стандартами**: Некоторые реализации могут лучше соответствовать стандартам Prolog, чем другие, что может быть важно для переносимости кода между разными средами.

- **Лицензирование и доступность**: Некоторые реализации могут иметь открытые лицензии и быть бесплатно доступными, в то время как другие могут иметь коммерческое использование или ограниченный доступ к некоторым функциям.

Выбор конкретной реализации Prolog может зависеть от конкретных потребностей разработчика, задач, которые требуется решить, и требований проекта.
## Возможности Prolog

Prolog предоставляет мощные возможности для символьных вычислений и логического программирования. Вот некоторые из основных возможностей, которые предлагает Prolog:

1. **Декларативное программирование**: Prolog использует декларативный подход, позволяя программистам описывать отношения между объектами и факты о предметной области, а не последовательность команд для выполнения.

2. **Логический вывод и инференция**: В основе Prolog лежит механизм логического вывода, который позволяет системе Prolog делать логические выводы на основе знаний и правил, заданных в программе.

3. **Шаблонное сопоставление (Pattern Matching)**: Prolog предоставляет механизм шаблонного сопоставления для унификации термов, что позволяет писать более гибкие и обобщенные программы.

4. **Рекурсия**: Prolog активно использует рекурсию для повторения итераций и выполнения поиска в глубину в базе данных фактов и правил.

5. **Манипуляции со списками**: Prolog обеспечивает мощные и удобные средства для работы со списками, включая возможность создания, объединения, разделения и обработки списков.

6. **Встроенная работа с символами и текстом**: Prolog имеет встроенную поддержку для обработки символов и строк, что полезно для различных приложений, таких как обработка естественного языка.

7. **Работа с базой знаний (Knowledge Base)**: В Prolog программы состоят из фактов и правил, формирующих базу знаний, которая используется для решения задач.

8. **Интеграция с другими языками**: Некоторые реализации Prolog предоставляют средства для интеграции с другими языками программирования, такими как C, Java или Python.

9. **Интерактивная среда и отладка**: Многие реализации Prolog предоставляют интерактивные среды разработки и отладки для пошагового выполнения программ и анализа процесса логического вывода.

10. **Искусственный интеллект и экспертные системы**: Prolog часто используется в различных областях искусственного интеллекта, включая разработку экспертных систем, обработку естественного языка, анализ данных и машинное обучение.
## Декларации и определения

В Прологе, когда необходимо использовать предикат, то это делается без каких-либо предварительных указаний движку Пролога о таких намерениях. Например, в предыдущих руководствах clause предиката был непосредственно записан с использованием традиционной для Пролога конструкции голова-тело. Мы не беспокоились о том, чтобы в тексте программы предупредить движок явно, что такая конструкция предиката потребуется.

Аналогично, когда в традиционном Прологе требуется использовать составной домен, мы можем его использовать без предупреждения движка по поводу этого намерения. Мы просто используем домен тогда, когда в этом возникает необходимость.

Однако, в Visual Prolog, перед написанием кода для тела клауза предиката мы должны сначала объявить о существовании такого предиката компилятору. Аналогично, перед использованием любых доменов они должны быть объявлены и представлены компилятору.

Причиной такой необходимости в предупреждениях является попытка как можно раньше обнаружить возможность исключений периода исполнения.

Под _"исключениями периода исполнения (runtime exceptions)"_, мы понимаем события, возникающие только во время исполнения программы. Например, если Вы вознамерились использовать целое число в качестве аргумента функтора, а вместо этого вы по ошибке использовали вещественное число, то в процессе исполнения возникла бы ошибка _периода исполнения_ (в программах, написанных для ряда компиляторов, не не для Visual Prolog) и программа в этом случае завершилась бы неуспешно.

Когда Вы объявляете предикаты или домены, которые определены, то появляется своего рода позиционная грамматика (какому домену принадлежит какой аргумент), доступная компилятору. Более того, когда Visual Prolog выполняет компиляцию, он тщательно проверяет программу на наличие таких грамматических ошибок, наряду с другими.

Благодаря этому свойству Visual Prolog, повышается конечная эффективность программиста. Программист не должен ждать, когда реально работающая программа совершит ошибку. Действительно, те из Вас, кто имеет опыт в программировании, понимает насколько этот код безопасен. Часто конкретная последовательность событий, приводящая к исключению периода исполнения кажется настолько неуловимой, что ошибка может проявиться через много лет, или она может заявить о себе в критической ситуации и привести к непредсказуемым последствиям!

Все это автоматически ведет к тому, что компилятор **должен** получать точные инструкции по поводу предикатов и доменов в виде соответствующих объявлений, которые должны предшествовать определениям.
## Концепции Visual Prolog

1. **Domains (Домены)**: Домены в Visual Prolog представляют типы данных или структуры данных, которые могут быть использованы для определения переменных и фактов в программе. Это может быть что-то подобное классам или структурам в других языках программирования. Например, можно определить домен для представления информации о человеке (имя, возраст, пол и т.д.).

2. **Clauses (Клаузы)**: Клаузы представляют логические утверждения или правила, используемые для логического вывода в программе на Prolog. Они состоят из фактов (конкретных утверждений) и правил (логических утверждений для вывода других фактов или правил). Клаузы определяют базу знаний программы.

3. **Предикаты и правила**: В Visual Prolog предикаты используются для описания логических отношений между фактами или правилами. Предикаты состоят из заголовка (имени предиката и его аргументов) и тела (логических утверждений, которые определяют условия выполнения предиката).

4. **Правила и логический вывод**: Visual Prolog использует правила для логического вывода. Они определяют, какие факты могут быть выведены из базы знаний на основе заданных правил и фактов.

5. **Интерфейс и работа с GUI**: В Visual Prolog есть инструменты для разработки графических пользовательских интерфейсов (GUI) с помощью которых можно создавать окна, кнопки, текстовые поля и другие элементы управления.

Эти концепции и инструменты в Visual Prolog позволяют программистам структурировать и описывать знания, разрабатывать логические правила и создавать приложения с графическим интерфейсом пользователя, используя принципы логического программирования, характерные для Prolog.
## Файловое структурирование программ

Необходимость помещения всех частей большой программы в один файл несомненно является неудобством. Это ведет к тому, что программа становится нечитаемой и иногда неправильной. Visual Prolog предусматривает возможность деления текста программы на отдельные файлы, используя среду IDE (Integrated Development Environment) и, кроме того, IDE позволяет помещать логически связанные фрагменты текста программы в отдельные файлы. Несмотря на такое разделение программы на части, сущности, находящиеся в общем использовании, доступны.

Например, если имеется домен, который используется несколькими файлами, то объявление домена делается в отдельном файле и к этому файлу из других файлов существует доступ.


## Работа с файлами в Visual Prolog 5.2 

Visual Prolog предоставляет некоторые инструменты для работы с файлами и доступа к ним. Вот как можно осуществить доступ одного файла к другому в Visual Prolog 5.2:

1. **Открытие файла для чтения и записи**: Для открытия файла в Visual Prolog используются предикаты `open/3`, `read/2`, `write/2` и другие. Например:

```prolog
clauses
    fileAccess :-
        FileName = "file.txt",
        FileMode = read,
        file::open(FileName, FileMode, File),
        % Чтение данных из файла
        file::read(File, Data),
        % Ваш код для обработки данных
        file::close(File).
```

В данном примере `file.txt` - это имя файла, `read` - режим открытия файла для чтения. Вы можете использовать `write` для открытия файла для записи.
- **Запись данных в файл**: Чтобы записать данные в файл, используйте предикат `write/2`:

```prolog
clauses
    writeToFile :-
        FileName = "output.txt",
        Data = "Hello, Visual Prolog!",
        FileMode = write,
        file::open(FileName, FileMode, File),
        file::write(File, Data),
        file::close(File).
```

- **Проверка существования файла**: Для проверки существования файла в Visual Prolog, используйте предикат `file::fileExists/1`:

```prolog
clauses
    checkFileExistence :-
        FileName = "file.txt",
        file::fileExists(FileName).
```

Это позволит вам проверить, существует ли файл `file.txt`.
## Обращения к другим файлам Prolog 

В Prolog, предикат `consult/1` используется для загрузки и выполнения кода из другого файла. Он позволяет загрузить программу Prolog, содержащую факты, правила и запросы, из указанного файла.

Пример использования `consult/1` для загрузки другого файла Prolog:

Предположим, у вас есть файл с именем "другой_файл.pl", который вы хотите загрузить в вашу программу. Вот как это можно сделать в Prolog:

```prolog
consult('другой_файл.pl').
```

Приведенная выше команда загрузит содержимое файла "другой_файл.pl" и выполнит его код в текущей среде Prolog. Файл должен находиться в том же каталоге, что и основная программа, или же вам нужно указать полный путь к файлу.

Примечание: В различных реализациях Prolog синтаксис и поддерживаемые функции могут немного отличаться, поэтому проверьте документацию вашей конкретной реализации Prolog для уточнения деталей использования `consult/1` или альтернативных способов загрузки кода из других файлов.


## База знаний в Prolog

База знаний (Knowledge Database) в Prolog представляет собой совокупность фактов и правил, которые программа использует для логического вывода и решения задач. В Prolog знания описываются с помощью фактов и правил, и это является основой логического программирования.

1. **Факты (Facts)**: Факты в Prolog представляют собой утверждения о предметах, описывающие отношения между объектами. Например:

```prolog
human(john).
age(john, 30).
```

	Эти факты говорят о том, что "john" - это человек и у него возраст 30 лет.

2. **Правила (Rules)**: Правила в Prolog описывают логические связи между фактами и позволяют делать логические выводы на основе существующих знаний. Например:
```prolog
older(X, Y) :- age(X, A), age(Y, B), A > B.
```

	Это правило говорит о том, что X старше Y, если возраст X больше возраста Y.

3. **Запросы (Queries)**: Программа на Prolog может выполнить запросы к базе знаний, используя встроенные предикаты, что позволяет находить решения на основе знаний базы данных. Например:

```prolog
?- human(john).
```

	Этот запрос проверяет, является ли "john" человеком (что соответствует факту).

4. **Логический вывод (Logical Inference)**: Пролог использует механизм унификации и логического вывода для поиска решений на основе правил и фактов. Путем формирования цепочек логических утверждений и применения правил к фактам, Prolog может находить решения для различных запросов.

База знаний в Prolog представляет собой основу для решения логических задач, обработки информации и логического вывода. Она может быть использована для моделирования различных предметных областей и создания экспертных систем.
## Пример базовой программы

``` prolog
domains 
	utype=integer

predicates
	sum(utype, utype)

clauses
	sum(1, 2).

goal
	sum(X, Y).
```

```output
X=1, Y=2
1 Solution
```
# Реализация экспертной системы по выбору стиральной машины на Visual Prolog 5.2

```prolog
DOMAINS
	DOMAINS 
  conditions = number*
  number = integer
  category = string
  
global facts - pravila
  topic(category)
  rule(number, category, category, conditions)
  cond(number, category)
  yes(number)
  no(number)
  
PREDICATES
  do_expert_job
  nondeterm show_menu
  nondeterm do_consulting
  nondeterm process(integer)
  info(category)
  goes(category)
  listopt
  clear
  eval_reply(char)
  nondeterm go(category)
  nondeterm check(number, conditions)
  inpo(number, number, string)
  do_answer(number, string, number, number)
  nondeterm append_new_topic
  nondeterm append_new_rule
  
CLAUSES 
  do_expert_job:-
    show_menu, nl,
    write("Press any key"), 
    readchar(_), exit.
  
  show_menu:-
    write("->  1 - consultation"), nl,
    write("->  2 - add new topic"), nl,
    write("->  3 - add new rule"), nl,
    write("->  0 - exit"), nl,
    readint(Choice), process(Choice).
    
  process(1):-
    do_consulting.
  process(2):-
    append_new_topic.
  process(3):-
    append_new_rule.
  process(0):-
    exit.
    
  do_consulting:-
    goes(Mygoal), 
    go(Mygoal), !.
  do_consulting:-
    nl, write("I cant help you").
  do_consulting.
  
  goes(MyGoal):-
    clear, nl,  
    write("To start enter 'washer'"), nl,
    write("If you want to see the washers types, enter '?'"), nl,
    readln(Mygoal), info(Mygoal), !.
    
  info("?"):-
    !, listopt, nl,
    exit.
  info("washer").
  
  listopt:-
    write("Washers types are: "), nl,
    topic(Washer),
    write("->",Washer), nl, fail.
  listopt.
  
  inpo(Rno, Bno, Text):-
    write("Question:- ", Text, "?"),nl,
    write("\tType 1 for 'yes': "), nl,
    write("\tType 2 for 'no': "), nl,
    readint(Response),
    do_answer(Rno, Text, Bno, Response).
    
  eval_reply('y'):-
    write("I hope you have found this helpful !").
  eval_reply('n'):-
    write("I am sorry I can't help you !").
    
  go(Mygoal):-
    NOT(rule(_, Mygoal, _, _)), !, nl,
    write("the washer you have indicated is a(n)", Mygoal, "."), nl,
    write("Is a washer you would like to have (y/n)?"), nl,
    readchar(R),
    eval_reply(R).
  go(Mygoal):-
    rule(Rno, Mygoal, Ny, Cond),
    check(Rno, Cond),
    go(Ny).
  
  check(Rno, [Bno|Rest]):-
    yes(Bno), !,
    check(Rno, Rest).
  check(_, [Bno|_]):-
    no(Bno), !, fail.
  check(Rno, [Bno|Rest]):-
    cond(Bno, Text), 
    inpo(Rno, Bno, Text),
    check(Rno, Rest).
  check(_, []).
  
  do_answer(_, _, _, 0):-
    exit.
  do_answer(_, _, Bno, 1):-
    assert(yes(Bno)),
    write("yes"), nl.
  do_answer(_, _, Bno, 2):-
    assert(no(Bno)),
    write("yes"), nl, fail.
  
  clear:-
    retract(yes(_)), fail;
    retract(no(_)), fail;
    !.
  append_new_topic:-
    write("Enter a body of topic: "),
    readln(Topic), assertz(topic(Topic)),
    save("base.dba", pravila),
    show_menu.
    
  append_new_rule:-
    write("Enter a new rule: "), nl,
    write("Enter a number of a rule(>30): "), readint(Number),
    write("Enter a type of washer(topic): "), readln(WasherType),
    write("Enter a name of washer: "), readln(WasherName),
    write("Enter a three property's of washer(integer numbers from 1 to 15): "),
    readint(FirstProperty), readint(SecondProperty), readint(ThirdProperty),
    assertz(rule(Number, WasherType, WasherName, [FirstProperty, SecondProperty, ThirdProperty])),
    save("base.dba", pravila),
    show_menu.
    
GOAL
  consult("base.dba", pravila),
  show_menu.
```
